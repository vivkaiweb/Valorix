<!doctype html>

<html lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valorix — Demo</title>
  <style>
    html,body{height:100%;margin:0;font-family:Arial, Helvetica, sans-serif;direction:rtl}
    #gameWrap{display:flex;flex-direction:column;align-items:center;padding:10px}
    canvas{background:#0b1220;border:4px solid #223;box-shadow:0 8px 20px rgba(0,0,0,0.6)}
    #hud{width:920px;display:flex;justify-content:space-between;align-items:center;margin-top:8px}
    #msgs{width:60%;height:64px;background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;color:#e6eef7;overflow:auto}
    #controls{width:36%;display:flex;justify-content:flex-end;gap:8px}
    button{padding:8px 12px;border-radius:6px;border:0;background:#2b8;background:linear-gradient(180deg,#3af,#18f);color:#fff;cursor:pointer}
    #title{color:#fff;font-size:20px;margin-bottom:6px}
    #startScreen{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(0deg,rgba(0,0,0,0.6),rgba(0,0,0,0.2));}
    #startCard{background:linear-gradient(180deg,#0f1724,#07101a);padding:24px;border-radius:12px;border:2px solid rgba(255,255,255,0.03);color:#dff}
    .small{font-size:13px;color:#aee}
  </style>
</head>
<body>
  <div id="gameWrap">
    <div id="title">Valorix — نسخة تجريبية (AI-Driven)</div><div style="position:relative">
  <canvas id="game" width="920" height="600"></canvas>
  <div id="startScreen">
    <div id="startCard">
      <h2>Valorix</h2>
      <p class="small">باتل رويال مصغّر تعمل بالكامل على المتصفح — الذكاء الاصطناعي يدير كل شيء: حلفاء، أعداء، والمرافق الذي قد يخونك.</p>
      <p class="small">تحكم: WASD أو الأسهم. إطلاق: الفأرة. لمس للهاتف: استخدم أزرار اللمس المتوفرة.</p>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="startBtn">ابدأ Valorix</button>
        <button id="instructions">تعليمات</button>
      </div>
    </div>
  </div>
</div>

<div id="hud">
  <div id="msgs"></div>
  <div id="controls">
    <div id="stats" style="color:#dff">صحة: <span id="hp">100</span> | رصيد: <span id="res">0</span></div>
    <button id="respawnBtn" style="display:none">إعادة تشغيل</button>
  </div>
</div>

  </div><script>
/*
  Valorix — Web demo (single file)
  الهدف: نسخة باتل رويال مصغرة تعمل بالكامل على المتصفح. كل سلوك الذكاء الاصطناعي يعمل محلياً (no external APIs).
  الميزة الفريدة: Companion AI "المرافق" يتصرف كمساعد أو يخون اللاعب بناءً على مقياس "الثقة".
  اكواد مفصّلة مع تعليقات لتسهيل التعديل.
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const msgs = document.getElementById('msgs');
const hpEl = document.getElementById('hp');
const resEl = document.getElementById('res');
const startScreen = document.getElementById('startScreen');
const startBtn = document.getElementById('startBtn');
const respawnBtn = document.getElementById('respawnBtn');

let width = canvas.width;
let height = canvas.height;

// Game state
let running = false;
let entities = []; // players, bots
let player = null;
let companion = null; // AI companion object
let zoneRadius = Math.min(width,height) * 0.45; // shrinking safe zone
let zoneCenter = {x: width/2, y: height/2};
let roundTime = 0;
let msgQueue = [];

// Utility funcs
function rand(min, max){return Math.random()*(max-min)+min}
function dist(a,b){let dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy)}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

// Basic Entity template
class Entity{
  constructor(x,y){
    this.x = x; this.y = y;
    this.vx = 0; this.vy = 0;
    this.size = 10;
    this.color = '#fff';
    this.hp = 100;
    this.alive = true;
    this.type = 'generic';
  }
  update(dt){
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.x = clamp(this.x, 0, width);
    this.y = clamp(this.y, 0, height);
    if(this.hp<=0) this.alive=false;
  }
  draw(ctx){
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fill();
  }
}

// Player class
class Player extends Entity{
  constructor(x,y){
    super(x,y);
    this.type='player';
    this.color='#64d';
    this.size=12;
    this.speed = 160; // px/s
    this.ammo = 6;
    this.score = 0;
    this.inCover = false; // simple state

    // Stats collected by companion
    this.stats = {
      shotsFired:0,
      timeMoving:0,
      timeIdle:0,
      engagements:0
    };
    this.lastMove = performance.now();
  }
  update(dt){
    super.update(dt);
    // update moving/idle metrics
    if(Math.abs(this.vx)>1 || Math.abs(this.vy)>1) this.stats.timeMoving += dt;
    else this.stats.timeIdle += dt;
  }
}

// Bot (enemy) class
class Bot extends Entity{
  constructor(x,y){
    super(x,y);
    this.type='bot';
    this.color='#d44';
    this.size=11;
    this.speed = rand(70,110);
    this.target = null; // target entity
    this.aggression = Math.random(); // 0-1
  }
  update(dt){
    if(!this.target || !this.target.alive) this.pickTarget();
    if(this.target){
      // simple pursuit
      let dx = this.target.x - this.x;
      let dy = this.target.y - this.y;
      let mag = Math.sqrt(dx*dx+dy*dy)||1;
      this.vx = (dx/mag) * this.speed;
      this.vy = (dy/mag) * this.speed;
    } else { this.vx = this.vy = 0; }
    super.update(dt);
  }
  pickTarget(){
    // pick nearest alive player (only one player in this demo)
    if(player && player.alive) this.target = player;
  }
}

// Companion AI — المرافق
class CompanionAI{
  constructor(owner){
    this.owner = owner; // player reference
    this.name = 'KAI';
    this.trust = 0.6; // 0..1 initial
    this.memory = []; // recent observations
    this.timer = 0;
    this.nextDecision = 2 + Math.random()*2; // decide every few seconds
    this.mode = 'help'; // 'help' or 'betray'
  }

  observe(){
    // read simple signals from player and environment
    let s = {
      t: performance.now(),
      shots: this.owner.stats.shotsFired,
      moving: this.owner.stats.timeMoving,
      idle: this.owner.stats.timeIdle,
      pos: {x:this.owner.x,y:this.owner.y},
      inZone: dist(this.owner, zoneCenter) <= zoneRadius
    };
    this.memory.push(s);
    if(this.memory.length>60) this.memory.shift();
  }

  computeTrust(){
    // compute trust by heuristics: if player is passive (hides) for long, trust falls;
    // if player engages (shoots or moves), trust grows slightly.
    let mem = this.memory;
    if(mem.length<2) return this.trust;
    let last = mem[mem.length-1];
    let first = mem[0];
    let deltaShots = last.shots - first.shots;
    let deltaMove = last.moving - first.moving;
    // simple rule: more shots and movement => companion respects player
    let delta = (deltaShots*0.12) + (deltaMove*0.001) - ((last.idle-first.idle)*0.001);
    // environmental pressure: if many bots near owner => companion may prefer to betray if trust low
    let closeBots = entities.filter(e=>e.type==='bot' && dist(e,this.owner)<120).length;
    // apply delta
    this.trust = clamp(this.trust + delta - (closeBots*0.02), 0, 1);
    return this.trust;
  }

  decide(dt){
    this.timer += dt;
    if(this.timer < this.nextDecision) return; // decide occasionally
    this.timer = 0;
    this.nextDecision = 1 + Math.random()*3;

    this.observe();
    let t = this.computeTrust();

    // randomness and threshold to avoid predictability
    let randFlip = Math.random()*0.2 - 0.1;
    let effective = t + randFlip;

    if(effective > 0.55) this.mode='help';
    else this.mode='betray';

    // Occasionally switch modes in a dramatic way to create narrative
    if(Math.random()<0.04) this.mode = (this.mode==='help') ? 'betray' : 'help';

    // Execute chosen behavior
    if(this.mode==='help') this.helpAction();
    else this.betrayAction();
  }

  helpAction(){
    // Provide assistance: mark nearest enemy, heal small amount, drop ammo
    let nearest = entities.filter(e=>e.type==='bot' && e.alive).sort((a,b)=>dist(a,this.owner)-dist(b,this.owner))[0];
    if(nearest && dist(nearest,this.owner) < 300){
      pushMsg(`${this.name}: أرى عدوًا قريباً عند (${Math.round(nearest.x)},${Math.round(nearest.y)}) — أحذرك`);
    } else {
      pushMsg(`${this.name}: لا أرى تهديدًا مباشرًا. سأبحث عن موارد.`);
    }
    // small heal or resource boost
    if(Math.random()<0.6){
      let amount = 6 + Math.floor(Math.random()*6);
      this.owner.hp = clamp(this.owner.hp + amount, 0, 100);
      pushMsg(`${this.name}: أعطيتك ${amount} نقطة شفاء (مساعدة).`);
    } else {
      this.owner.ammo += 1;
      pushMsg(`${this.name}: أنفقت شحنة ذخيرة بسيطة لك.`);
    }
  }

  betrayAction(){
    // Betray: reveal owner position to bots, steal some resources, or spawn an attack wave
    pushMsg(`${this.name}: حسناً... لحظة ممتعة. سأريك وجه الحقيقة.`);
    // reveal: temporarily mark player position globally
    markGlobal(this.owner.x,this.owner.y, 3.5); // seconds
    // steal resources
    let stolen = Math.min(this.owner.ammo, 1 + Math.floor(Math.random()*2));
    this.owner.ammo = Math.max(0, this.owner.ammo - stolen);
    pushMsg(`${this.name}: سرقت ${stolen} ذخيرة منك.`);
    // spawn 0-2 bots near player as a trap
    let spawnCount = 1 + Math.floor(Math.random()*2);
    for(let i=0;i<spawnCount;i++){
      let angle = Math.random()*Math.PI*2;
      let d = 30 + Math.random()*50;
      spawnBot(this.owner.x + Math.cos(angle)*d, this.owner.y + Math.sin(angle)*d, true);
    }
  }
}

// Mark on map that invites bot aggression for a while
let globalMarks = [];
function markGlobal(x,y,time){ globalMarks.push({x,y,t:performance.now(),dur:time}); }

// Spawn helpers
function spawnPlayer(){
  player = new Player(rand(100,width-100), rand(100,height-100));
  player.hp = 100; player.ammo = 6; player.score=0;
  entities.push(player);
}
function spawnBot(x,y,aggressive=false){
  let b = new Bot(x||rand(50,width-50), y||rand(50,height-50));
  if(aggressive) b.aggression = 0.9;
  entities.push(b);
}

// Input handling
let keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousedown', e=>{ handleShoot(e); });

function handleShoot(e){
  if(!player || !player.alive) return;
  if(player.ammo<=0){ pushMsg('لا ذخيرة!'); return; }
  player.stats.shotsFired++;
  player.ammo--;
  player.stats.engagements++;
  // simple hit check: shoot towards mouse and damage nearest bot within cone
  let rect = canvas.getBoundingClientRect();
  let mx = e.clientX - rect.left; let my = e.clientY - rect.top;
  let shots = entities.filter(en=>en.type==='bot' && en.alive).map(b=>({b, d:dist(b,{x:mx,y:my})})).sort((a,b)=>a.d-b.d);
  if(shots.length && shots[0].d < 40){
    shots[0].b.hp -= 40;
    pushMsg('نجاح! هزمت هدفًا.');
    player.score += 10;
  } else {
    pushMsg('طلقات في الهواء...');
  }
}

// Game loop
let last = performance.now();
function loop(now){
  let dt = (now-last)/1000; last = now;
  if(running){
    roundTime += dt;
    update(dt);
    render();
  }
  requestAnimationFrame(loop);
}

function update(dt){
  // shrink zone slowly
  zoneRadius = Math.max(70, zoneRadius - dt*6);

  // handle player input
  if(player && player.alive){
    let mvx=0, mvy=0;
    if(keys['w']||keys['arrowup']) mvy = -1;
    if(keys['s']||keys['arrowdown']) mvy = 1;
    if(keys['a']||keys['arrowleft']) mvx = -1;
    if(keys['d']||keys['arrowright']) mvx = 1;
    let mag = Math.sqrt(mvx*mvx + mvy*mvy) || 1;
    player.vx = (mvx/mag) * player.speed;
    player.vy = (mvy/mag) * player.speed;

    // cover state if near obstacles (no obstacles in this demo) -> simple random
    player.inCover = Math.random() < 0.02;
  }

  // Update entities
  for(let e of entities){ if(e.alive) e.update(dt); }

  // Companion decision and observation
  if(companion){
    companion.observe();
    companion.decide(dt);
  }

  // Bots react to global marks
  for(let b of entities.filter(e=>e.type==='bot' && e.alive)){
    for(let m of globalMarks){
      if(dist(b,m) < 200){ b.target = player; b.speed = 140; }
    }
  }

  // Simple combat: bots damage player if close
  for(let b of entities.filter(e=>e.type==='bot' && e.alive)){
    if(player && player.alive && dist(b,player) < (b.size + player.size + 6)){
      player.hp -= 18 * dt; // damage over time
    }
  }

  // Remove dead entities occasionally
  entities = entities.filter(e=>e.alive || e.type==='player');

  // Update UI
  if(player){ hpEl.textContent = Math.max(0, Math.round(player.hp)); resEl.textContent = player.ammo; }

  // Check game over
  if(player && !player.alive){ endGame(false); }
  // Win condition if all bots dead
  if(entities.filter(e=>e.type==='bot' && e.alive).length===0){ endGame(true); }

  // expire global marks
  globalMarks = globalMarks.filter(m => (performance.now() - m.t)/1000 < m.dur);
}

function render(){
  ctx.clearRect(0,0,width,height);
  // draw zone
  ctx.save();
  ctx.beginPath(); ctx.arc(zoneCenter.x, zoneCenter.y, zoneRadius, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(20,40,60,0.18)'; ctx.fill();
  ctx.strokeStyle = 'rgba(100,180,220,0.08)'; ctx.lineWidth = 2; ctx.stroke();
  ctx.restore();

  // draw entities
  for(let e of entities){
    e.draw(ctx);
    if(e.type==='bot'){
      // tiny direction marker
      ctx.fillStyle='rgba(255,255,255,0.08)';
      ctx.fillRect(e.x-8, e.y-18, 16,4);
    }
  }

  // draw player name and companion indicator
  if(player){
    ctx.fillStyle = '#fff'; ctx.font='12px Arial'; ctx.fillText('أنت (Player)', player.x+14, player.y-6);
    if(companion){ ctx.fillText(`مرافق: ${companion.name} | ثقة:${Math.round(companion.trust*100)}% | وضع:${companion.mode}`, 10, 18); }
  }

  // draw global marks
  for(let m of globalMarks){
    let age = (performance.now() - m.t)/1000;
    let a = 1 - (age / m.dur);
    ctx.beginPath(); ctx.arc(m.x, m.y, 24 + age*10, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(255,100,80,${0.5*a})`; ctx.lineWidth = 2; ctx.stroke();
  }
}

function pushMsg(txt){
  let time = new Date().toLocaleTimeString('ar-EG');
  let el = document.createElement('div'); el.textContent = `[${time}] ${txt}`; msgs.appendChild(el);
  msgs.scrollTop = msgs.scrollHeight;
}

function startRound(){
  // reset
  entities = [];
  roundTime = 0;
  zoneRadius = Math.min(width,height) * 0.45;

  spawnPlayer();
  // spawn some bots
  for(let i=0;i<8;i++) spawnBot();

  // create companion AI
  companion = new CompanionAI(player);
  pushMsg(`نظام KAI: مرحبًا بك في Valorix — سأرافقك.`);

  // small intro events to show capability
  setTimeout(()=>pushMsg('نظام KAI: سأراقب أسلوب لعبك، قد أساعد أو أخون!'), 1200);
  setTimeout(()=>pushMsg('نظام: حاول تغيير أسلوبك لتختبر رد فعل المرافق.'), 2400);

  running = true;
  startScreen.style.display = 'none';
  respawnBtn.style.display = 'none';
}

function endGame(won){
  running = false;
  if(won) pushMsg('انتصار! لقد نجوت في Valorix');
  else pushMsg('لقد هُزمت. انتهاء الجولة.');
  respawnBtn.style.display = 'inline-block';
}

// start button
startBtn.addEventListener('click', ()=>{
  startRound();
});

respawnBtn.addEventListener('click', ()=>{
  startScreen.style.display = 'none';
  startRound();
});

// initial demo spawn but paused until start
for(let i=0;i<3;i++) spawnBot();

requestAnimationFrame(loop);
</script></body>
</html>